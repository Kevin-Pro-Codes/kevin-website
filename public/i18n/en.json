{

    "nav1": "Home",
    "nav2": "Portfolio",
    "nav3": "Extras",
    "nav4": "Contact",
    "st1": "About",
    "st2": "Copyright Terms",
    "st3": "Articles",
    "st4": "Images",    
    "st5": "Projects",
    "st6": "Co-op",
    "st7": "Algo Trading Bot",
    "st8": "Languages",
    "views": "This site was visited:",
    "views2": "times.",
    "feedback": "GIVE YOUR FEEDBACK OR ASK A QUESTION",
    "update": "GET INFORMED ABOUT THE LATEST UPDATES",
    "subscribe": "SUBSCRIBE",
    "send": "SEND",
    "search": "Search...",
    "comment": "Message...",
    
    "greeting": "GREETINGS",   
    "about-atext": "My name is Kevin, I was born in Switzerland in 1994 and moved to Brazil after 1 and a half years. Son of a Brazilian mother and a Portuguese father, I have relatives spread across Europe and Brazil. Moving forward, I have an interest in computer programming and also emphasize my general interest in languages. I graduated as a Radiology Technician and worked for years in my father's business, then decided to migrate to the IT field.",
    "about-title": "WHAT IS THIS SITE ABOUT?",
    "about-btext": "This site mainly focuses on projects in the field of information technology (programming), more specifically in: C, C++, Java, Web, and Android. I am pleased to present my projects and intentions. I am also interested in programming trading robots and have some languages as a hobby, things that are also part of the IT field. In my programming history, I began to understand it in intermittent periods and saw concepts like variables and conditions in Ruby from RPG Maker XP. Shortly after, I started programming some bots for the game Tibia called Elf Bot, where I handled general programming in the Lua language. Years later, I took a C language course, and that’s when more serious studies began. I read a 350-page book in a short time and scored 10/10 on the C exam. Shortly after, I started dealing with other content like C++ and created my first C++ project with over 6,000 lines of code, which ran in the IDE console. This project brought me joy because I understood that building a project requires discipline and organization. That’s when I took an in-person HTML course and then got involved with CSS and JavaScript (this site was built in HTML5, CSS3, JavaScript). Java and MySQL made things more interesting, making it surprising to deal with a purely object-oriented language. After that, I developed a passion for Web Browsers, like the one I built in the Java framework, called JavaFX. Then, realizing that the beginning of the mobile era dealt with Java, I decided to learn Kotlin, and it became one of my main focuses in programming. I have the perspective that any project being developed must follow principles, and everything done results in lessons learned. It is through this type of notion that I adapt to the posture and standards of a company. I am always open to learning the syntax of programming languages, understanding lexical and semantic parameters, and existing programming methodologies. I will mention some areas in which I want to develop skills or acquire knowledge that will enhance my capabilities in future programming. Let's start with Assembly: this programming language is at the opposite pole of more abstract languages as it is a low-level language. It is closely related to machine language, and the use of a low-level language is not just about movements we make through robotics, like microprocessors, but basic and small things that are indispensable for an operating system, like its drivers. It can also be part of how an IDE compiles a language through the low-level code it is written in. ARM Assembly and WebAssembly have a direct relationship with the low level of Android, and this is interesting. Another thing I want to get in touch with and improve is leaning toward the fundamentals of computer science because it gives the programmer the apparatus for a better programming structure. Moreover, programming challenges like 'LeetCode' are always useful for practice, for me in languages like Java or Kotlin, but the extra complexity about where a language can go through its libraries and functions should not be explored too deeply without something practical and useful. It is important to improve the NoSQL area and acquire knowledge about how a database works with certain programming languages. I also find Machine Learning interesting in programming environments that simulate autonomous cars, usually in Python and C++, such as CARLA.",

    "rights": "© 2024 Kevin. All rights reserved.",
    "rights2": "Supported by: <span class='blue-text'>Halo Algo Trading</span> <img src='/images/halo.png' alt='Icon' class='halo' width='55' height='36' style='padding-top: 4px;'> and <span class='blue-text'>Solar Corp</span><a href='#' target='_blank'><img src='/images/solaricon.png' alt='Icon' class='sun' width='55' height='48' style='padding-bottom: 5px;'></i></a>",      
    "and": "and",





"copyright-title": "COMMITMENT TERM OF NON-REPRODUCTION AND NON-DISTRIBUTION OF COPYRIGHTED CONTENT",
"copyright-text": "By this Commitment Term of Non-Reproduction and Non-Distribution of Copyrighted Content, the person identified as THE COPYRIGHT HOLDER declares that the content of the website \"www.kevinws.netlify.app\", here referred to as COPYRIGHTED CONTENT and the projects found therein, is their exclusive creation and ownership, being protected by the Copyright Law (Law No. 9.610/1998). Clause 1 - Prohibition of Reproduction and Distribution 1.1. Any form of reproduction, copy, distribution, exhibition, adaptation, transmission, or any other use of the COPYRIGHTED CONTENT is strictly prohibited without the prior express written authorization of the COPYRIGHT HOLDER (for projects or content not disclosed in open code networks such as GitHub). 1.2. This term prohibits the creation of derivative works or modifications of the COPYRIGHTED CONTENT, as well as the sharing of all or part of it in any physical, digital, or public or private platform, without authorization. Clause 2 - Prohibition of Commercial Use 2.1. Commercial use of the COPYRIGHTED CONTENT is prohibited, including but not limited to sale, rental, licensing, or any other form of economic exploitation without express authorization. 2.2. The COPYRIGHTED CONTENT may not be used in promotional, advertising, or any other form of publicity for profit. Clause 3 - Penalties for Non-Compliance 3.1. The non-compliance of any provision of this Term by third parties may lead to applicable legal measures, including judicial actions for the repair of damages and losses, as well as penalties provided in the current copyright and intellectual property legislation. 3.2. The infringer may be held civilly and criminally liable for improper use, unauthorized reproductions, or any other form of violation of the COPYRIGHT HOLDER's copyright. Clause 4 - Jurisdiction 4.1. To resolve any disputes arising from this Term, the parties elect the court of [City and State], with express waiver of any other, however privileged it may be. By being in full agreement with the terms set forth herein, the parties sign this Commitment Term of Non-Reproduction and Non-Distribution of Copyrighted Content in [number of copies] copies of equal content and form.<br> Ilhéus, Bahia 2025 <br> _____________________________________  <br> Kevin Ferreira",




"articles-title": "ANALYSIS OF PROGRAMMING PARADIGMS",
"articles-text": "This article provides information about the complexity of programming languages and algorithms. It addresses topics such as: the types of languages, their structure, whether they are low or high level, strong or weak typing, compilation and interpretation, what this represents, among others. Such topics are discussed and analyzed in a simple manner, allowing laypeople to understand the existence of aspects present in programming languages. Finally, in the conclusion, the main points discussed throughout the article are highlighted, emphasizing the importance of understanding the fundamentals of information technology for professional success in the field. Reflections are made on the future trends of programming languages and their implications for software development, among other things. Keywords: IT; algorithms; programming languages; market. The foundations of information technology are essential factors for the contextualization of a good professional in the field; they are subjects of study that strengthen the training of a capable, flexible, and insightful professional. A professional who develops algorithms can never overlook the importance of their foundational studies from the past, such as the creation of truth tables, flowcharts, programming vocabulary, syntax, lexical, and semantic rules in a programming language. It is worth remembering that problems of a certain type return in unknown forms that may seem complex but can be simple; thus, each problem takes a specific time and form for its solution through algorithms, for example. The introduction to algorithmic thinking occurs, and then the professional becomes capable of using their programming style, knowing that programming itself is something \"linguistic\" and mathematical at the same time. Such awareness makes him an explorer of vast horizons, as within a programming language there will be additional content, such as libraries and frameworks, which are nothing more than tools that add resources to some programming languages. The programmer makes robotic arms work, for example, in Arduino, or in the case of self-driving cars, like the services provided by Comma Ai and Yandex, as well as everything that permeates information and social connections, resource disclosures, and innovation; all of this involves algorithmic codes and programming. It is worth remembering that important foundations in an IT company also include its administration and its resources and tools, the management practices they adopt, the dissemination of information, as well as their internal and external communication, how and to what extent an employee is communicated with or can communicate. Another factor is that IT is part of most companies today, making software creation, resource management, communication, sharing, among other resources, crucial for their survival, maintenance, and ascension. Nowadays, in addition to hierarchies, there are qualifications such as junior, mid-level, and senior, which serve to classify the status of a programmer or project leader, making years of experience or advanced skills in programming categorize them in this way.",

"articles-title2": "CHARACTERISTICS OF ALGORITHMS",


    "articles-text2": "Algorithms have characteristics ranging from basic to more advanced, as well as their classification according to what type they are in a programming language. Among some classifications is the procedural paradigm, which involves using \"procedures\" or \"subroutines\". Functions are used followed by functions, considering the scopes and rules of control flow, variables and control structures such as (loops and conditionals). This is similar to the imperative paradigm, as it involves telling the machine exactly what should be done, so basically it expresses the logic of a computation without specifying the control flow, in other words, it is focused on describing what needs to be achieved instead of how to achieve it, thus, a programming language can be included in more than one paradigm per se. Another programming paradigm is the functional language, which occurs in the way that functions can be declared in variables, passed as arguments and returned from other functions. Another key point is the idea of \"pure functions\". A pure function depends only on its input to generate a result and given the same input, the same result is produced. With these concepts in mind, functional programming encourages programs to be written mostly as functions. It also advocates the idea that modularity and the absence of side effects make it easier to identify and separate responsibilities in the source code. Also, the declarative programming paradigm is about hiding complexity and bringing programming languages closer to human language and thought. This is the direct opposite of imperative language in the sense that the programmer does not give instructions on how the computer should perform a task, but rather what result is required. The famous object-oriented paradigm is one of the most famous today, which is about separating functionalities into entities that are coded as objects. Each entity will group together a certain set of information (properties) and actions (methods) that can be performed by the entity. OOP makes heavy use of classes, which is a way of creating new objects starting from a technical drawing that the programmer puts in. Objects that are created from classes are called instances. The great thing about OOP is that it makes the program easier to understand by clearly separating concepts and responsibilities. Another interesting topic in this subject of programming languages is their characteristics as high and low level languages. Low level languages are geared towards machine understanding. Therefore, they have a more complex syntax and do not have such intuitive commands. For example: remember the \"print\" instructions? Although they are easy for a person to assimilate, it is clear that the computer is not capable of understanding such a command. This is because machine language is made up only of sequences of 0 and 1, the so-called binary code. Therefore, low level languages have more direct instructions for the processor and are therefore closer to machine language. Therefore, to use them, it is necessary to know not only the language, but also the hardware of the device with which you will work. Among the main advantages and disadvantages of low level languages is the faster processing time than that of a high level language. In addition, the architecture of the devices is better used with this type of language. On the other hand, the person who will use this low level tool may take longer to understand and master the syntax. Not to mention that it will still be necessary to have in-depth knowledge of the machine's hardware, which requires more investment in study and training. Furthermore, since the written code is more processor-oriented, portability is also impaired, as it may not run on processors from different families. Furthermore, the main low-level language we have is Assembly. We call a high-level language a language whose syntax is geared towards human understanding. This means that this type of language is much more intuitive, abstract and easier to learn, especially for beginners in the programming field. To make this possible, high-level languages abstract concepts geared towards the machine and synthesize commands. For example: \"print\" and \"delete\" are instructions commonly used in these languages that, as the terms suggest, serve to display information on the screen or delete some data, respectively. Among the advantages and disadvantages of high-level programming languages is the great benefit and productivity that the programmer gains when using this type of language. This is because the abstraction provided by high-level languages allows you to write more code in less time, which is extremely positive when working on complex systems. Furthermore, if someone else needs to check your code, they will be able to understand more easily what was done. This way, the maintenance process is also simplified. On the other hand, high-level languages have some disadvantages. There are cases, for example, in which the performance of a program may be affected because it requires more processing time. They also usually take up more memory when compared to a low-level language. Some of the high-level languages are: Javascript, Java, C#, C++, Python, Ruby, Swift, PHP. Another thing to note is when a language is compiled or interpreted. Compiled is the type of language that is translated into machine code before execution, resulting in faster processing, thus requiring separate compilation for different platforms. The compilation process involves several steps, including lexical analysis, syntactic analysis, code optimization, and machine code generation. The result is an executable file or an object code library that can be executed by the computer's CPU. An interpreted language is a type of programming language in which the source code is executed directly by a program called an interpreter, without the need for prior compilation to machine code. The interpreter reads and executes the instructions of the source code line by line during the execution of the program. It should not be forgotten that in programming languages memory (RAM) management is relevant. Memory management is a fundamental part of software development, especially in lower-level programming languages such as C and C++, where programmers have more direct control over memory allocation and deallocation. However, even in higher-level languages such as Java, Python, and JavaScript, memory management is an important consideration, although it is often done in a more transparent way to the developer. An additional point is language typing, which is classified as: weak and strong typing. In a weakly typed language, automatic conversions between data types are often allowed and can occur implicitly. In a strongly typed language, automatic conversions between data types are restricted or disallowed, requiring that the types be compatible before performing an operation.",
  
  
"articles-title3": "RESULTS AND DISCUSSIONS",

"articles-text3": "It is important to be aware of the fact that each programming language has its function in IT, some closer to machine language and others further away, among other factors and categories as mentioned above. Although the market varies from one region to another (even considering internationally), the market shows a pattern. Thus, each programming language has its space, because in some cases the low demand for jobs can be compensated by high payments for performing the function. It is worth noting the great growth of languages ​​such as Python and Javascript. Python has become an essential tool in practically all scientific applications around the world due to its power and versatility. It is a general-purpose programming language that supports different programming paradigms. This language is widely used in scientific and specialized applications, including data science, artificial intelligence, machine learning, computer science education, computer vision and image processing, medicine, biology and even astronomy. Python is also used for web development. This is where we can start comparing its applications with JavaScript applications. Python is used for back-end development, which is the area of ​​web development responsible for creating the elements that users don't see, such as the server side of an application. While Python can be used to develop the back-end portion of a web application, JavaScript can be used to develop both the back-end and front-end portions of the application. The front-end is the part of the application that the user sees and interacts with. Whenever you view or interact with a website or web application, you are using JavaScript \"under the hood\" .Similarly, when you interact with a mobile application, you may be using JavaScript, because frameworks like React Native allow us to write applications that adapt to different platforms. JavaScript is so widely used in web development because it is a versatile language that provides the tools necessary to develop the components of a web application.",

"articles-title4": "CONCLUSION",

"articles-text4": "It is concluded that taking into account the general characteristics of programming languages ​​and their types of structure, means of compilation, and levels of abstraction, a notion of outline is added to the programmer, thus suggesting how to deal with such a language, and possibly predicting aspects of it. It should be considered that markets and employability vary from region to region, but in general everything is heading in a similar direction. It is seen that there may be some hidden trends, such as the rise of languages ​​such as Rust and C# replacing C++ and Java, respectively, since one of the factors is the current solution that such languages ​​bring to problems and also the functional operability when it comes to the use of memory that software written in such languages ​​demands. An interesting point is how linguistic and mathematical an algorithm can be at the same time. Among the lexical, syntactic, and semantic rules limited in their creation, thus making languages ​​something that expands and at the same time has a limit. The C++ language's limitless approach is conveyed through its level of abstraction, data, and structure, thus supporting software such as Photoshop, with over 10 million lines of code, among others. Programming languages ​​can be compiled or interpreted. Compiled languages ​​are translated completely into machine language before the program is executed, while interpreted languages ​​are translated line by line during the program's execution. Each programming language has its own ecosystem of tools, libraries, frameworks, and developer community. This can affect productivity, ease of learning, and the support available to programmers. In short, programming languages ​​play a crucial role in software development, providing developers with the tools they need to create a wide variety of software applications and systems. Choosing the right programming language depends on the project requirements, personal preferences, and experience of the developers.",




     "title-contact": "CONTACTS"
    
 

}


